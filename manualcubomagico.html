<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Rubik's Cube</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 15px;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            background: linear-gradient(145deg, #0f4c75, #1d6fa5);
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover {
            background: linear-gradient(145deg, #1d6fa5, #0f4c75);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.6);
        }
        button:active {
            transform: translateY(1px) translateX(-50%);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        #controls button:active {
             transform: translateY(1px);
        }
    </style>
</head>
<body>

    <div id="controls">
        <button id="scrambleButton">Auto Scramble</button>
        <button id="solveButton">Auto Solve</button>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Configuration Constants ---
        const CUBE_SIZE = 3;
        const CUBIE_SIZE = 1;
        const GAP = 0.05;
        const TURN_SPEED = 15; // Degrees per frame
        const DRAG_THRESHOLD = 50; // Pixels needed to register a swipe (screen space)

        // Standard Rubik's Cube Colors (Hex)
        const COLORS = {
            U: 0xFFFF00, D: 0xFFFFFF, 
            F: 0x0000FF, B: 0x00FF00, 
            L: 0xFF8800, R: 0xFF0000, 
            CORE: 0x0a0a0a, 
        };

        // Rotation definitions (Axis vector, Rotation direction sign)
        const AXES = {
            'x': new THREE.Vector3(1, 0, 0),
            'y': new THREE.Vector3(0, 1, 0),
            'z': new THREE.Vector3(0, 0, 1)
        };
        const ROTATIONS = {
            'R': { axis: 'x', dir: -1 }, 'L': { axis: 'x', dir: 1 },
            'U': { axis: 'y', dir: -1 }, 'D': { axis: 'y', dir: 1 },
            'F': { axis: 'z', dir: -1 }, 'B': { axis: 'z', dir: 1 },
            'R\'': { axis: 'x', dir: 1 }, 'L\'': { axis: 'x', dir: -1 },
            'U\'': { axis: 'y', dir: 1 }, 'D\'': { axis: 'y', dir: -1 },
            'F\'': { axis: 'z', dir: 1 }, 'B\'': { axis: 'z', dir: -1 }
        };

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let cubies = [];
        let currentMove = null;
        let moveQueue = [];
        let scrambleMoves = []; 

        // --- Interaction State ---
        let raycaster, mouse;
        let isDragging = false;
        let startMousePos = new THREE.Vector2();
        let targetCubie = null;
        let targetFaceNormal = new THREE.Vector3();
        let currentMoveStarted = false;

        // --- Setup Functions ---
        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e); 
            document.body.appendChild(renderer.domElement);

            // 2. Lighting and Cube creation
            setupLighting();
            createCube();

            // 3. Camera and Controls
            camera.position.set(3, 4, 5);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 10;
            controls.update();

            // 4. Interaction tools
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // 5. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            
            document.getElementById('scrambleButton').addEventListener('click', scrambleCube);
            document.getElementById('solveButton').addEventListener('click', solveCube);
            
            // Mouse Interaction Listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            
            // Touch Interaction Listeners (for responsiveness)
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Start the animation loop
            animate();
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight1.position.set(5, 5, 5);
            scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);
        }

        function createCube() {
            const size = CUBIE_SIZE + GAP;
            const offset = (CUBE_SIZE - 1) * size / 2;
            
            const faceColors = [
                COLORS.R, COLORS.L, COLORS.U, COLORS.D, COLORS.F, COLORS.B 
            ];

            for (let x = 0; x < CUBE_SIZE; x++) {
                for (let y = 0; y < CUBE_SIZE; y++) {
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        
                        const materials = [];
                        for (let i = 0; i < 6; i++) {
                            let isOuterFace = false;
                            
                            // Determine which faces are visible (3x3 outer layer)
                            if (i === 0 && x === CUBE_SIZE - 1) isOuterFace = true; // +X (R)
                            if (i === 1 && x === 0) isOuterFace = true;             // -X (L)
                            if (i === 2 && y === CUBE_SIZE - 1) isOuterFace = true; // +Y (U)
                            if (i === 3 && y === 0) isOuterFace = true;             // -Y (D)
                            if (i === 4 && z === CUBE_SIZE - 1) isOuterFace = true; // +Z (F)
                            if (i === 5 && z === 0) isOuterFace = true;             // -Z (B)

                            if (isOuterFace) {
                                materials.push(new THREE.MeshLambertMaterial({ color: faceColors[i] }));
                            } else {
                                materials.push(new THREE.MeshLambertMaterial({ color: COLORS.CORE }));
                            }
                        }
                        
                        const cubieGeometry = new THREE.BoxGeometry(CUBIE_SIZE, CUBIE_SIZE, CUBIE_SIZE);
                        const cubie = new THREE.Mesh(cubieGeometry, materials);
                        
                        cubie.position.set(
                            x * size - offset,
                            y * size - offset,
                            z * size - offset
                        );
                        
                        cubie.userData = {
                            originalPos: { x, y, z }, // Used to identify which slice the cubie belongs to
                        };

                        cubies.push(cubie);
                        scene.add(cubie);
                    }
                }
            }
        }

        // --- Move Functions ---

        function startMove(move, isManual = false) {
            if (currentMove) {
                moveQueue.push(move);
                return;
            }
            
            const moveData = ROTATIONS[move];
            if (!moveData) return;

            const cubiesToMove = getCubiesForMove(move);

            if (cubiesToMove.length === 0) {
                if (moveQueue.length > 0) {
                    startMove(moveQueue.shift());
                }
                return;
            }
            
            currentMove = {
                ...moveData,
                moveName: move,
                targetAngle: Math.PI / 2, 
                angle: 0,
                cubies: cubiesToMove,
                cubieGroup: groupCubies(cubiesToMove),
                isManual: isManual
            };
            
            // Update scramble history
            if (isManual && scrambleMoves.length > 0) {
                // If the manual move is the inverse of the last scramble move, cancel it out
                const lastScrambleMove = scrambleMoves[scrambleMoves.length - 1];
                if (getInverseMove(lastScrambleMove) === move) {
                    scrambleMoves.pop();
                } else {
                    scrambleMoves.push(move);
                }
            } else if (!isManual) {
                // If auto-scramble, record it
                scrambleMoves.push(move);
            }

            controls.enabled = false; // MUST be disabled during rotation
            currentMoveStarted = true;
        }

        function getCubiesForMove(move) {
            const moveData = ROTATIONS[move];
            const axis = moveData.axis; 
            
            let sliceIndex;
            const baseMove = move.charAt(0); 
            
            // Determine which layer index to select based on the move name
            if (['L', 'D', 'B'].includes(baseMove)) {
                sliceIndex = 0; // The layer on the negative side of the axis
            } else if (['R', 'U', 'F'].includes(baseMove)) {
                sliceIndex = CUBE_SIZE - 1; // The layer on the positive side of the axis
            } else {
                return []; 
            }
            
            return cubies.filter(cubie => {
                return cubie.userData.originalPos[axis] === sliceIndex;
            });
        }

        function groupCubies(cubieList) {
            const pivot = new THREE.Object3D();
            scene.add(pivot);
            cubieList.forEach(cubie => {
                // Attach the cubie to the pivot object
                pivot.attach(cubie);
            });
            return pivot;
        }
        
        function unGroupCubies(cubieList, pivot) {
            // Re-attach cubies to the scene and update their original position data
            cubieList.forEach(cubie => {
                scene.attach(cubie);
                updateOriginalPositions(cubie);
            });
            scene.remove(pivot);
            
            controls.enabled = true; // Re-enable orbit controls when move is done
            currentMoveStarted = false;
        }

        function updateOriginalPositions(cubie) {
            const size = CUBIE_SIZE + GAP;
            const offset = (CUBE_SIZE - 1) * size / 2;
            const worldPos = new THREE.Vector3();
            cubie.updateWorldMatrix(true, false); 
            cubie.getWorldPosition(worldPos);
            
            // Converts the world coordinate back to the 0-2 index
            const coordToIndex = (coord) => {
                // Round to the nearest whole number for the index
                const index = Math.round((coord + offset) / size); 
                return THREE.MathUtils.clamp(index, 0, CUBE_SIZE - 1);
            };

            cubie.userData.originalPos = { 
                x: coordToIndex(worldPos.x), 
                y: coordToIndex(worldPos.y), 
                z: coordToIndex(worldPos.z) 
            };
        }


        // --- Interaction Handlers ---

        function getMouseVector(event) {
            const clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
            const clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
            
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            return mouse;
        }

        function onMouseDown(event) {
            if (currentMove || currentMoveStarted) return;
            isDragging = true;
            startMousePos.copy(getMouseVector(event));
            
            raycaster.setFromCamera(startMousePos, camera);
            const intersects = raycaster.intersectObjects(cubies);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                targetCubie = intersect.object;
                
                // Get the world normal of the face that was hit
                targetFaceNormal.copy(intersect.face.normal).transformDirection(targetCubie.matrixWorld);
                
                // If we hit a cubie, temporarily disable OrbitControls to detect a slice drag
                controls.enabled = false;
            } else {
                targetCubie = null;
                // If nothing is hit, controls remain ENABLED for orbiting
                controls.enabled = true; 
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault(); // Prevent scrolling/zoom
            onMouseDown(event.touches[0]);
        }


        function onMouseMove(event) {
            // Only need to worry about controls if we are currently trying to drag a face
            if (isDragging && targetCubie) {
                controls.enabled = false;
            }
        }
        
        function onTouchMove(event) {
            if (isDragging && targetCubie) {
                controls.enabled = false;
            }
        }


        function onMouseUp(event) {
            if (!isDragging || currentMove) {
                // Reset dragging state and ensure controls are on if nothing happened
                isDragging = false;
                controls.enabled = true;
                return;
            }

            isDragging = false;
            
            if (!targetCubie) {
                 // If the click started on the background, the orbit controls handled it, we just reset state
                controls.enabled = true; 
                return;
            }

            const endMousePos = getMouseVector(event);

            // Calculate drag distance in screen space
            const dx = endMousePos.x - startMousePos.x;
            const dy = endMousePos.y - startMousePos.y;
            
            // Calculate pixel distance (approximated for screen density)
            const pixelDistance = Math.sqrt(dx * dx + dy * dy) * window.innerWidth;

            if (pixelDistance < DRAG_THRESHOLD) {
                // Drag too small, user likely just tapped or tried to orbit without hitting background
                targetCubie = null;
                controls.enabled = true;
                return;
            }
            
            // Determine move using the robust logic
            const move = determineMove(targetFaceNormal, dx, dy, camera);
            
            if (move) {
                startMove(move, true); // True indicates a manual move
            } else {
                // If a drag was detected but didn't map to a valid move (e.g., drag along the face axis), re-enable controls
                controls.enabled = true; 
            }
            
            targetCubie = null;
        }
        
        function onTouchEnd(event) {
            onMouseUp(event.changedTouches[0]);
        }

        /**
         * Determines the correct Rubik's move (e.g., 'R', 'U\'', 'F') based on the clicked face normal
         * and the screen-space drag vector (dx, dy) relative to the camera's orientation.
         */
        function determineMove(normal, dx, dy, camera) {
            // Normalize the normal vector to a simple axis (+-1, 0, 0, etc.)
            const n = new THREE.Vector3().copy(normal).round();
            let axis, baseMove;

            // 1. Determine the axis of rotation and the base move (R, L, U, D, F, B)
            if (Math.abs(n.x) > 0.9) { 
                axis = 'x'; baseMove = n.x > 0 ? 'R' : 'L'; 
            } else if (Math.abs(n.y) > 0.9) { 
                axis = 'y'; baseMove = n.y > 0 ? 'U' : 'D'; 
            } else if (Math.abs(n.z) > 0.9) { 
                axis = 'z'; baseMove = n.z > 0 ? 'F' : 'B'; 
            } else {
                return null;
            }

            const isHorizontalSwipe = Math.abs(dx) > Math.abs(dy);
            const swipeMagnitude = isHorizontalSwipe ? dx : dy;
            
            // 2. Determine world vectors for screen's right and up
            const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const cameraUp = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);
            
            let rotationAxisWorld = AXES[axis];
            let rotationMove = null;
            let targetVector = new THREE.Vector3(); // The vector on the face that the swipe is parallel to

            // 3. Determine the 3D direction of the swipe for each face
            if (axis === 'x') { // R/L Faces (Rotation around X)
                if (isHorizontalSwipe) return null; // Only vertical swipe should trigger R/L
                
                // Rotation plane is YZ. Target vector is orthogonal to the rotation axis and screen right (to project onto the face plane).
                targetVector.crossVectors(rotationAxisWorld, cameraRight); 
                
                // The dot product tells us if screen UP (dy) aligns with the calculated targetVector
                const dot = targetVector.dot(cameraUp);
                
                // isCW = is Clockwise (R, U, F, D', L', B')
                // A positive dot means screen UP aligns with the direction that produces a CW move for R
                const isCW = (dot * swipeMagnitude) > 0;

                if (baseMove === 'R') {
                    rotationMove = isCW ? 'R' : 'R\'';
                } else { // L face
                    rotationMove = isCW ? 'L\'' : 'L'; // L is inverse of R's direction
                }

            } else if (axis === 'y') { // U/D Faces (Rotation around Y)
                if (!isHorizontalSwipe) return null; // Only horizontal swipe should trigger U/D

                // Rotation plane is XZ. Target vector is orthogonal to the rotation axis and screen up.
                targetVector.crossVectors(rotationAxisWorld, cameraUp); 
                
                // The dot product tells us if screen RIGHT (dx) aligns with the calculated targetVector
                const dot = targetVector.dot(cameraRight);

                // A positive dot means screen RIGHT aligns with the direction that produces a CW move for U
                const isCW = (dot * swipeMagnitude) > 0;
                
                if (baseMove === 'U') {
                    rotationMove = isCW ? 'U' : 'U\'';
                } else { // D face
                    rotationMove = isCW ? 'D\'' : 'D'; // D is inverse of U's direction
                }

            } else if (axis === 'z') { // F/B Faces (Rotation around Z)
                // We check which swipe component (horizontal or vertical) is stronger
                
                if (isHorizontalSwipe) {
                    // Horizontal Swipe (Rotation in XY plane, primarily X-axis movement on face)
                    targetVector.crossVectors(rotationAxisWorld, cameraUp);
                    const dot = targetVector.dot(cameraRight);
                    const isCW = (dot * swipeMagnitude) > 0;

                    if (baseMove === 'F') {
                        rotationMove = isCW ? 'F' : 'F\'';
                    } else { // B face
                        rotationMove = isCW ? 'B\'' : 'B';
                    }
                } else {
                    // Vertical Swipe (Rotation in XY plane, primarily Y-axis movement on face)
                    targetVector.crossVectors(rotationAxisWorld, cameraRight);
                    const dot = targetVector.dot(cameraUp);
                    
                    // NOTE: This direction is often inverted for the F face due to visual intuition.
                    const isCW = (dot * swipeMagnitude) > 0; 

                    if (baseMove === 'F') {
                        rotationMove = isCW ? 'F\'' : 'F'; // Inverted intuitive direction for F
                    } else { // B face
                        rotationMove = isCW ? 'B' : 'B\'';
                    }
                }
            }
            
            return rotationMove;
        }


        // --- Scramble/Solve Functions ---

        function scrambleCube() {
            if (currentMove || moveQueue.length > 0) return;
            
            const moves = ['R', 'L', 'U', 'D', 'F', 'B', 'R\'', 'L\'', 'U\'', 'D\'', 'F\'', 'B\''];
            scrambleMoves = [];
            
            // 25 random moves for a good scramble
            for (let i = 0; i < 25; i++) {
                const move = moves[Math.floor(Math.random() * moves.length)];
                scrambleMoves.push(move);
                moveQueue.push(move);
            }
        }

        function getInverseMove(move) {
            if (move.endsWith('\'')) {
                return move.slice(0, -1);
            } else {
                return move + '\'';
            }
        }

        function solveCube() {
            if (currentMove || moveQueue.length > 0 || scrambleMoves.length === 0) return;
            
            // Apply the inverse of the scramble sequence in reverse order
            const solveSequence = [];
            for (let i = scrambleMoves.length - 1; i >= 0; i--) {
                solveSequence.push(getInverseMove(scrambleMoves[i]));
            }
            
            scrambleMoves = []; // Clear history after solving
            moveQueue.push(...solveSequence);
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            if (currentMove) {
                // Calculate step size in radians
                const step = currentMove.dir * TURN_SPEED * Math.PI / 180;
                let newAngle = currentMove.angle + Math.abs(step);
                
                // Check if the rotation is complete
                if (newAngle >= currentMove.targetAngle) {
                    // Final rotation to snap to exactly 90 degrees
                    const finalStep = currentMove.dir * (currentMove.targetAngle - currentMove.angle);
                    currentMove.cubieGroup.rotateOnAxis(AXES[currentMove.axis], finalStep);
                    
                    unGroupCubies(currentMove.cubies, currentMove.cubieGroup);
                    currentMove = null;

                    if (moveQueue.length > 0) {
                        const nextMove = moveQueue.shift();
                        startMove(nextMove);
                    }
                } else {
                    currentMove.cubieGroup.rotateOnAxis(AXES[currentMove.axis], step);
                    currentMove.angle = newAngle;
                }
            } else if (moveQueue.length > 0) {
                startMove(moveQueue.shift());
            }

            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- Utilities ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the simulation when the page loads
        window.onload = init; 

    </script>
</body>
</html>
