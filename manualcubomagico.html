<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Rubik's Cube</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 15px;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            background: linear-gradient(145deg, #0f4c75, #1d6fa5);
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover {
            background: linear-gradient(145deg, #1d6fa5, #0f4c75);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.6);
        }
        button:active {
            transform: translateY(1px) translateX(-50%);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        #controls button:active {
             transform: translateY(1px);
        }
    </style>
</head>
<body>

    <div id="controls">
        <button id="scrambleButton">Auto Scramble</button>
        <button id="solveButton">Auto Solve</button>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Configuration Constants ---
        const CUBE_SIZE = 3;
        const CUBIE_SIZE = 1;
        const GAP = 0.05;
        const TURN_SPEED = 15; // Degrees per frame
        const DRAG_THRESHOLD = 50; // Pixels needed to register a swipe

        // Standard Rubik's Cube Colors (Hex)
        const COLORS = {
            U: 0xFFFF00, D: 0xFFFFFF, 
            F: 0x0000FF, B: 0x00FF00, 
            L: 0xFF8800, R: 0xFF0000, 
            CORE: 0x0a0a0a, 
        };

        const AXES = {
            'x': new THREE.Vector3(1, 0, 0),
            'y': new THREE.Vector3(0, 1, 0),
            'z': new THREE.Vector3(0, 0, 1)
        };
        const ROTATIONS = {
            'R': { axis: 'x', dir: -1 }, 'L': { axis: 'x', dir: 1 },
            'U': { axis: 'y', dir: -1 }, 'D': { axis: 'y', dir: 1 },
            'F': { axis: 'z', dir: -1 }, 'B': { axis: 'z', dir: 1 },
            'R\'': { axis: 'x', dir: 1 }, 'L\'': { axis: 'x', dir: -1 },
            'U\'': { axis: 'y', dir: 1 }, 'D\'': { axis: 'y', dir: -1 },
            'F\'': { axis: 'z', dir: 1 }, 'B\'': { axis: 'z', dir: -1 }
        };

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let cubies = [];
        let currentMove = null;
        let moveQueue = [];
        let scrambleMoves = []; 

        // --- Interaction State ---
        let raycaster, mouse;
        let isDragging = false;
        let startMousePos = new THREE.Vector2();
        let targetCubie = null;
        let targetFaceNormal = new THREE.Vector3();
        let currentMoveStarted = false;

        // --- Setup Functions ---
        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e); 
            document.body.appendChild(renderer.domElement);

            // 2. Lighting and Cube creation
            setupLighting();
            createCube();

            // 3. Camera and Controls
            camera.position.set(3, 4, 5);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 10;
            controls.update();

            // 4. Interaction tools
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // 5. Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            
            document.getElementById('scrambleButton').addEventListener('click', scrambleCube);
            document.getElementById('solveButton').addEventListener('click', solveCube);
            
            // Mouse Interaction Listeners
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            
            // Touch Interaction Listeners (for responsiveness)
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            // Start the animation loop
            animate();
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight1.position.set(5, 5, 5);
            scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);
        }

        function createCube() {
            const size = CUBIE_SIZE + GAP;
            const offset = (CUBE_SIZE - 1) * size / 2;
            
            const faceColors = [
                COLORS.R, COLORS.L, COLORS.U, COLORS.D, COLORS.F, COLORS.B 
            ];

            for (let x = 0; x < CUBE_SIZE; x++) {
                for (let y = 0; y < CUBE_SIZE; y++) {
                    for (let z = 0; z < CUBE_SIZE; z++) {
                        
                        const materials = [];
                        for (let i = 0; i < 6; i++) {
                            let isOuterFace = false;
                            
                            if (i === 0 && x === CUBE_SIZE - 1) isOuterFace = true; // +X (R)
                            if (i === 1 && x === 0) isOuterFace = true;             // -X (L)
                            if (i === 2 && y === CUBE_SIZE - 1) isOuterFace = true; // +Y (U)
                            if (i === 3 && y === 0) isOuterFace = true;             // -Y (D)
                            if (i === 4 && z === CUBE_SIZE - 1) isOuterFace = true; // +Z (F)
                            if (i === 5 && z === 0) isOuterFace = true;             // -Z (B)

                            if (isOuterFace) {
                                materials.push(new THREE.MeshLambertMaterial({ color: faceColors[i] }));
                            } else {
                                materials.push(new THREE.MeshLambertMaterial({ color: COLORS.CORE }));
                            }
                        }
                        
                        const cubieGeometry = new THREE.BoxGeometry(CUBIE_SIZE, CUBIE_SIZE, CUBIE_SIZE);
                        const cubie = new THREE.Mesh(cubieGeometry, materials);
                        
                        cubie.position.set(
                            x * size - offset,
                            y * size - offset,
                            z * size - offset
                        );
                        
                        cubie.userData = {
                            originalPos: { x, y, z },
                        };

                        cubies.push(cubie);
                        scene.add(cubie);
                    }
                }
            }
        }

        // --- Move Functions (Same as proven logic) ---

        function startMove(move, isManual = false) {
            if (currentMove) {
                moveQueue.push(move);
                return;
            }
            
            const moveData = ROTATIONS[move];
            if (!moveData) return;

            const cubiesToMove = getCubiesForMove(move);

            if (cubiesToMove.length === 0) {
                if (moveQueue.length > 0) {
                    startMove(moveQueue.shift());
                }
                return;
            }
            
            currentMove = {
                ...moveData,
                moveName: move,
                targetAngle: Math.PI / 2, 
                angle: 0,
                cubies: cubiesToMove,
                cubieGroup: groupCubies(cubiesToMove),
                isManual: isManual
            };
            
            // If manual, remove the move from scramble history
            if (isManual && scrambleMoves.length > 0) {
                const lastScrambleMove = scrambleMoves[scrambleMoves.length - 1];
                if (getInverseMove(lastScrambleMove) === move) {
                    scrambleMoves.pop();
                } else {
                    scrambleMoves.push(move);
                }
            } else if (!isManual) {
                // If auto-scramble, record it
                scrambleMoves.push(move);
            }

            controls.enabled = false; // Disable orbit controls during rotation
            currentMoveStarted = true;
        }

        function getCubiesForMove(move) {
            const moveData = ROTATIONS[move];
            const axis = moveData.axis; 
            
            let sliceIndex;
            const baseMove = move.charAt(0); 
            
            if (['L', 'D', 'B'].includes(baseMove)) {
                sliceIndex = 0; 
            } else if (['R', 'U', 'F'].includes(baseMove)) {
                sliceIndex = CUBE_SIZE - 1; 
            } else {
                return []; 
            }
            
            return cubies.filter(cubie => {
                return cubie.userData.originalPos[axis] === sliceIndex;
            });
        }

        function groupCubies(cubieList) {
            const pivot = new THREE.Object3D();
            scene.add(pivot);
            cubieList.forEach(cubie => {
                pivot.attach(cubie);
            });
            return pivot;
        }
        
        function unGroupCubies(cubieList, pivot) {
            cubieList.forEach(cubie => {
                scene.attach(cubie);
                updateOriginalPositions(cubie);
            });
            scene.remove(pivot);
            
            controls.enabled = true; // Re-enable orbit controls
            currentMoveStarted = false;
        }

        function updateOriginalPositions(cubie) {
            const size = CUBIE_SIZE + GAP;
            const offset = (CUBE_SIZE - 1) * size / 2;
            const worldPos = new THREE.Vector3();
            cubie.updateWorldMatrix(true, false); 
            cubie.getWorldPosition(worldPos);
            
            const coordToIndex = (coord) => {
                const index = Math.round((coord + offset) / size);
                return THREE.MathUtils.clamp(index, 0, CUBE_SIZE - 1);
            };

            cubie.userData.originalPos = { 
                x: coordToIndex(worldPos.x), 
                y: coordToIndex(worldPos.y), 
                z: coordToIndex(worldPos.z) 
            };
        }


        // --- Interaction Handlers ---

        function getMouseVector(event) {
            const clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
            const clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
            
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            return mouse;
        }

        function onMouseDown(event) {
            if (currentMove || currentMoveStarted) return;
            isDragging = true;
            controls.enabled = false; // Disable orbit control on drag start
            startMousePos.copy(getMouseVector(event));
            
            raycaster.setFromCamera(startMousePos, camera);
            const intersects = raycaster.intersectObjects(cubies);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                targetCubie = intersect.object;
                
                // Get the world normal of the face that was hit
                targetFaceNormal.copy(intersect.face.normal).transformDirection(targetCubie.matrixWorld);
            } else {
                targetCubie = null;
                controls.enabled = true; // Re-enable if no cubie hit
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault(); // Prevent scrolling/zoom
            onMouseDown(event.touches[0]);
        }


        function onMouseMove(event) {
            if (!isDragging || currentMove || !targetCubie) return;
        }
        
        function onTouchMove(event) {
            if (!isDragging || currentMove || !targetCubie) return;
            // Prevent camera orbit if drag is over cubie
            controls.enabled = false;
        }


        function onMouseUp(event) {
            if (!isDragging || currentMove || !targetCubie) {
                isDragging = false;
                controls.enabled = true;
                return;
            }

            isDragging = false;
            const endMousePos = getMouseVector(event);

            // Calculate drag distance in screen space
            const dx = endMousePos.x - startMousePos.x;
            const dy = endMousePos.y - startMousePos.y;
            
            const pixelDistance = Math.sqrt(dx * dx + dy * dy) * window.innerWidth; // Convert to rough pixel measure

            if (pixelDistance < DRAG_THRESHOLD) {
                // If drag distance is too small, treat it as a failed move/camera slight movement
                targetCubie = null;
                controls.enabled = true;
                return;
            }
            
            // Determine move based on face normal and swipe direction
            const move = determineMove(targetFaceNormal, dx, dy);
            
            if (move) {
                startMove(move, true); // True indicates a manual move
            } else {
                controls.enabled = true; // Re-enable if no move was determined
            }
            
            targetCubie = null;
        }
        
        function onTouchEnd(event) {
            onMouseUp(event.changedTouches[0]);
        }

        function determineMove(normal, dx, dy) {
            let axis, sliceIndex, move;
            
            // Normalize the normal vector to a simple direction (+-1)
            const n = new THREE.Vector3().copy(normal).round();

            // --- Determine Axis and Slice ---
            if (Math.abs(n.x) > 0.9) {
                axis = 'x';
                sliceIndex = n.x > 0 ? CUBE_SIZE - 1 : 0; // R or L
            } else if (Math.abs(n.y) > 0.9) {
                axis = 'y';
                sliceIndex = n.y > 0 ? CUBE_SIZE - 1 : 0; // U or D
            } else if (Math.abs(n.z) > 0.9) {
                axis = 'z';
                sliceIndex = n.z > 0 ? CUBE_SIZE - 1 : 0; // F or B
            } else {
                return null;
            }

            // --- Determine Move Direction (Clockwise/Counter-clockwise) ---
            
            // Helper to get camera direction relative to the clicked face
            const cameraDir = new THREE.Vector3().subVectors(camera.position, targetCubie.position).normalize();
            
            // The cross product determines the positive rotation direction (Right Hand Rule)
            // If the camera is roughly aligned with the normal, X swipe is R/L, Y swipe is U/D
            
            let swipeDir = 0; // 1 for positive, -1 for negative rotation relative to cube logic

            if (axis === 'x') { // R/L Face
                // Rotation is around X-axis. Swipe plane is YZ.
                // We use Y (screen up/down) and Z (screen right/left projection)
                
                // Get the world up vector projected onto the screen (approx Y axis)
                const worldUp = new THREE.Vector3(0, 1, 0).applyQuaternion(controls.object.quaternion).y;
                
                if (Math.abs(dy) > Math.abs(dx)) { // Dominant vertical swipe
                    // Vertical swipe (dy > 0 is up, dy < 0 is down)
                    // If camera is looking from +Z (default), Up swipe = F->U = R
                    // Since R is dir=-1, and L is dir=1, R face: up-swipe is R (dir=-1)
                    swipeDir = dy > 0 ? -1 : 1; 
                } else { // Dominant horizontal swipe
                    // Horizontal swipe (dx > 0 is right, dx < 0 is left)
                    // This is less intuitive, ignoring for simplicity
                    return null;
                }

                if (sliceIndex === CUBE_SIZE - 1) { // R face
                    move = swipeDir < 0 ? 'R' : 'R\'';
                } else { // L face
                    move = swipeDir < 0 ? 'L\'' : 'L'; // L is inverse of R's direction
                }
            
            } else if (axis === 'y') { // U/D Face
                // Rotation is around Y-axis. Swipe plane is XZ.
                
                if (Math.abs(dx) > Math.abs(dy)) { // Dominant horizontal swipe
                    // Horizontal swipe (dx > 0 is right, dx < 0 is left)
                    swipeDir = dx > 0 ? 1 : -1; 
                } else {
                    return null;
                }
                
                if (sliceIndex === CUBE_SIZE - 1) { // U face
                    move = swipeDir > 0 ? 'U' : 'U\'';
                } else { // D face
                    move = swipeDir > 0 ? 'D\'' : 'D'; 
                }

            } else if (axis === 'z') { // F/B Face
                // Rotation is around Z-axis. Swipe plane is XY.
                
                if (Math.abs(dx) > Math.abs(dy)) { // Dominant horizontal swipe
                    // Horizontal swipe (dx > 0 is right, dx < 0 is left)
                    swipeDir = dx > 0 ? -1 : 1; 
                } else {
                    return null;
                }

                if (sliceIndex === CUBE_SIZE - 1) { // F face
                    move = swipeDir < 0 ? 'F' : 'F\'';
                } else { // B face
                    move = swipeDir < 0 ? 'B\'' : 'B'; 
                }
            }
            
            return move;
        }


        // --- Scramble/Solve Functions ---

        function scrambleCube() {
            if (currentMove || moveQueue.length > 0) return;
            
            const moves = ['R', 'L', 'U', 'D', 'F', 'B', 'R\'', 'L\'', 'U\'', 'D\'', 'F\'', 'B\''];
            scrambleMoves = [];
            
            for (let i = 0; i < 25; i++) {
                const move = moves[Math.floor(Math.random() * moves.length)];
                scrambleMoves.push(move);
                moveQueue.push(move);
            }
        }

        function getInverseMove(move) {
            if (move.endsWith('\'')) {
                return move.slice(0, -1);
            } else {
                return move + '\'';
            }
        }

        function solveCube() {
            if (currentMove || moveQueue.length > 0 || scrambleMoves.length === 0) return;
            
            const solveSequence = [];
            for (let i = scrambleMoves.length - 1; i >= 0; i--) {
                solveSequence.push(getInverseMove(scrambleMoves[i]));
            }
            
            scrambleMoves = []; 
            moveQueue.push(...solveSequence);
        }

        // --- Animation Loop ---

        function animate() {
            requestAnimationFrame(animate);

            if (currentMove) {
                const step = currentMove.dir * TURN_SPEED * Math.PI / 180;
                let newAngle = currentMove.angle + Math.abs(step);
                
                if (newAngle >= currentMove.targetAngle) {
                    const finalStep = currentMove.dir * (currentMove.targetAngle - currentMove.angle);
                    currentMove.cubieGroup.rotateOnAxis(AXES[currentMove.axis], finalStep);
                    
                    unGroupCubies(currentMove.cubies, currentMove.cubieGroup);
                    currentMove = null;

                    if (moveQueue.length > 0) {
                        const nextMove = moveQueue.shift();
                        startMove(nextMove);
                    }
                } else {
                    currentMove.cubieGroup.rotateOnAxis(AXES[currentMove.axis], step);
                    currentMove.angle = newAngle;
                }
            } else if (moveQueue.length > 0) {
                startMove(moveQueue.shift());
            }

            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- Utilities ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the simulation when the page loads
        window.onload = init; 

    </script>
</body>
</html>
